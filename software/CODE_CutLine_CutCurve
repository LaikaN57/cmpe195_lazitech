[a-zA-Z].* TOKEN_LETTER
[0-9][.][0-9] TOKEN_DIGIT

"q"	SaveOnStack
"Q" 	RestoreFromStack
"w" 	TOKEN_WIDTH
"J" 	TOKEN_CAP
"j" 	TOKEN_JOIN
"d" 	TOKEN_DASH
"h" 	TOKEN_MOVE
"S" 	TOKEN_STROKE
"f*" 	TOKEN_STROKE
"B" 	TOKEN_STROKE
"b" 	TOKEN_STROKE
"b*" 	TOKEN_STROKE
"s" 	TOKEN_STOKE_SAVE
"m" 	TOKEN_SUBPATH
"c" 	TOKEN_CURVE
"v" 	TOKEN_CURVE
"y" 	TOKEN_CURVE
"re" 	TOKEN_RECTANGLE
"h" 	TOKEN_CLOSE_PATH
"n" 	TOKEN_END

DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT CURVE { add_curve($1, $2, $3, $4, $5, $6); }
add_curve(int a, b, c, d, e, f) {
	// add curve to stack

	// return;
}

TOKEN_STROKE { stroke(); }
stroke() {
	origin(x,y)// move to origin

	// laser_on();

	while() {
		// actually move the motors and laser
	}

	// laser_off();
}

DIGIT DIGIT DIGIT DIGIT LINE {cut_line($1, $2, $3, $4);}

DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT CURVE_CUT {cut_curve($1, $2, $3, $4, $5, $6, $7, $8);}


DIGIT DIGIT DIGIT DIGIT line_cap {line_cap($1, $2, $3, $4);}

line_cap(){}

DIGIT DIGIT DIGIT DIGIT line_joint {line_joint($1, $2, $3, $4);}

line_joint() {}


/* if this is called the laser is already on. DONT MESS UP. */
void cut_line(double x1, double y1, double x2, double y2) 
{
	double[] pts = double x1, double y1, double x2, double y2;
	double pt1 = (x1, y1);
	double pt2 = (x2, y2);
	 (uint32_t) PIC32MX_IO->RPA0 = 0000;
	// bit 0: x step
	// bit 1: x dir
	// bit 2: y step
	// bit 3: y dir //0000

	// dir = 0 is neg
	// dir = 1 is pos

	// set X and Y dir pins
	if(x2 > x1) {
		(uint32_t) FIO2PIN |= (1 << 1);//set 1
	} else {
		FIO2PIN &= ~(1 << 1); // clear
	}

	if(y2 > y1) {
		FIO2PIN |= (1 << 3); //set 1
	} else {
		FIO2PIN &= ~(1 << 3); //set 0 (clear)
	}

	// set X and Y stepper pins
	if(x2 > x1) {
		(uint32_t) FIO2PIN |= (1 << 0);//set 1
	} else {
		FIO2PIN &= ~(1 << 0); clear
	}

	if(y2 > y1) {
		FIO2PIN |= (1 << 2); //set 1
	} else {
		FIO2PIN &= ~(1 << 2); //set 0 (clear)
	}

	for(int i = 0; pt1 < pt2; i++) {
		(uint32_t) FIO2PIN |= (1 << 0); // step x
		(uint32_t) FIO2PIN |= (1 << 1);// dir x

		//calc error between x and y
		double x_curr_pt = double x;
		double y_curr_pt = double y;
		double x_err = x1 - x_curr_pt;
		double y_err = y1 - y_curr_pt;		
		double slope = y_err / x_err; // also rise/run

		if (x_err < y_err)
		{
			(uint32_t) FIO2PIN |= (1 << 0); // step x
			(uint32_t) FIO2PIN |= (1 << 1);// dir x
		}
		else
		{
			(uint32_t) FIO2PIN &= ~(1 << 0); // clear step x
			(uint32_t) FIO2PIN &= ~(1 << 1);// clear dir x	
			(uint32_t) FIO2PIN |= (1 << 2); // step y 
			(uint32_t) FIO2PIN |= (1 << 3); // dir y
		}
		
		FIO2PIN &= ~(5 << 0); // turns off laser 
	}

	/* DO NOT USE THIS HERE
	for(x1 > x2) {
		//step x
	}

	for(y1 > y2) {
		//step y
	} */

//CLOCK IN bit 15:8 (8 bit) CFGCON
	IOLOCK |= (1 << 1); //set the CLK
	IOLOCK &= ~(1 << 1); //clear the CLK
}

/*void cut_line(double x1, double y1, double x2, double y2) 
{
	cut_curve(
		x1, y1,
		x1, y1,
		x2, y2,
		x2, y2);
}*/

void origin (double x, double y)
{
	double length = ???; // default length of machine 
	double height = ???; // default height of machine	
	x_offset= current x - length;
	y_offset = current y - height;
}

void default()
{
	stroke = "black";
	linewidith = 1;
	origin = {0,0};
}

/* if this is called the laser is already on. DONT MESS UP. */
void cut_curve(double[] pts) // input as an XYXYXYXY
{
	double[] pts = double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4;
	int mid = (pts.length / 2) // mid-pt
	double x_step, y_step;
	
	for (int i = 0; i != pts, i++)
	{	
		
		cut_line (x1, y1, x2, y2);

	}
}

/*Donâ€™t need*/
void pt(double x, double y) // General Point form for all four pts 
{ 
	P= Pt(x, y);
}


//Bezier Curve formula 
double bezier_curve (double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
{
	Pt1 = ( x1,  y1);
	Pt2 = ( x2,  y2);
	Pt3 = ( x3,  y3);
	Pt4 = ( x4,  y4);

	int t;
	int t2 = t * t;
	int t3 = t2 * t;
	int tx = 1-t;
	int tx2 = tx * tx;
	int tx3 = tx2 * tx;
	return ((tx3 * Pt1) + (3 * t * tx2 * Pt2) + (3 * t2 * tx * Pt3) + (t3 * Pt4));
	
}
